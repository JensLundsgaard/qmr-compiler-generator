ProblemDefinition { imp: ImplBlock { routed_gates: [CX], data: NamedTuple { name: "NisqCnot", fields: [("u", LocationTy), ("v", LocationTy)] }, realize: ITE { cond: CallMethod { d: Arch, method: "contains_edge", args: [Tuple([MapAccess(GetData { d: Gate, access: Access("qubits", ArrayAccess(IndexLiteral(0), Nil)) }), MapAccess(GetData { d: Gate, access: Access("qubits", ArrayAccess(IndexLiteral(1), Nil)) })])] }, then: CallFunction { func: "Some", args: [ImplConstructorExpr([("u", MapAccess(GetData { d: Gate, access: Access("qubits", ArrayAccess(IndexLiteral(0), Nil)) })), ("v", MapAccess(GetData { d: Gate, access: Access("qubits", ArrayAccess(IndexLiteral(1), Nil)) }))])] }, els: NoneExpr } }, trans: TransitionBlock { data: NamedTuple { name: "Swap", fields: [("edge", TupleTy([LocationTy, LocationTy]))] }, apply: SwapPair(GetData { d: Transition, access: Access("edge", TupleAccess(IndexLiteral(0), Nil)) }, GetData { d: Transition, access: Access("edge", TupleAccess(IndexLiteral(1), Nil)) }), cost: ITE { cond: Equal(Tuple([GetData { d: Transition, access: Access("edge", Nil) }]), Tuple([LocationLiteral(0), LocationLiteral(0)])), then: FloatLiteral(0.0), els: FloatLiteral(1.0) }, get_transitions: Append { vec: MapIterExpr { container: CallMethod { d: Arch, method: "edges", args: [] }, bound_var: "x", func: TransitionConstructor([("edge", Ident("x"))]) }, elem: TransitionConstructor([("edge", Tuple([LocationLiteral(0), LocationLiteral(0)]))]) } }, arch: None, step: None }