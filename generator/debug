ProblemDefinition { imp: ImplBlock { data: NamedTuple { name: "NisqCnot", fields: [("u", LocationTy), ("v", LocationTy)] }, realize: ITE { cond: CallMethod { d: Arch, method: "contains_edge", args: [Tuple([MapAccess(GetData { d: Gate, access: ArrayAccess("qubits", IndexLiteral(0)) }), MapAccess(GetData { d: Gate, access: ArrayAccess("qubits", IndexLiteral(1)) })])] }, then: CallFunction { func: "Some", args: [ImplConstructorExpr([("u", MapAccess(GetData { d: Gate, access: ArrayAccess("qubits", IndexLiteral(0)) })), ("v", MapAccess(GetData { d: Gate, access: ArrayAccess("qubits", IndexLiteral(1)) }))])] }, els: NoneExpr } }, trans: TransitionBlock { data: NamedTuple { name: "Swap", fields: [("edge", TupleTy([LocationTy, LocationTy]))] }, apply: SwapPair(GetData { d: Transition, access: TupleAccess("edge", IndexLiteral(0)) }, GetData { d: Transition, access: TupleAccess("edge", IndexLiteral(1)) }), cost: ITE { cond: Equal(Tuple([GetData { d: Transition, access: Field("edge") }]), Tuple([LocationLiteral(0), LocationLiteral(0)])), then: FloatLiteral(0.0), els: FloatLiteral(1.0) }, get_transitions: Append { vec: MapIterExpr { container: CallMethod { d: Arch, method: "edges", args: [] }, bound_var: "x", func: TransitionConstructor([("edge", Ident("x"))]) }, elem: TransitionConstructor([("edge", Tuple([LocationLiteral(0), LocationLiteral(0)]))]) } }, arch: None, step: None }