ProblemDefinition { imp: ImplBlock { routed_gates: [Pauli], data: NamedTuple { name: "MQLSSGate", fields: [("tree", VectorTy(LocationTy))] }, realize: ITE { cond: Equal(Tuple([CallMethod { d: Gate, method: "gate_type", args: [] }]), Tuple([Ident("PauliMeasurement")])), then: MapIterExpr { container: CallFunction { func: "steiner_trees", args: [Ident("arch"), Extend { vec1: Extend { vec1: Extend { vec1: Extend { vec1: EmptyVec, vec2: MapIterExpr { container: CallMethod { d: Gate, method: "x_indices", args: [] }, bound_var: "x", func: CallFunction { func: "horizontal_neighbors", args: [MapAccess(Ident("x")), GetData { d: Arch, access: Access("width", Nil) }] } } }, vec2: MapIterExpr { container: CallMethod { d: Gate, method: "z_indices", args: [] }, bound_var: "x", func: CallFunction { func: "vertical_neighbors", args: [MapAccess(Ident("x")), GetData { d: Arch, access: Access("width", Nil) }, GetData { d: Arch, access: Access("height", Nil) }] } } }, vec2: MapIterExpr { container: CallMethod { d: Gate, method: "y_indices", args: [] }, bound_var: "x", func: CallFunction { func: "vertical_neighbors", args: [MapAccess(Ident("x")), GetData { d: Arch, access: Access("width", Nil) }, GetData { d: Arch, access: Access("height", Nil) }] } } }, vec2: MapIterExpr { container: CallMethod { d: Gate, method: "y_indices", args: [] }, bound_var: "x", func: CallFunction { func: "horizontal_neighbors", args: [MapAccess(Ident("x")), GetData { d: Arch, access: Access("width", Nil) }] } } }, Extend { vec1: Extend { vec1: CallFunction { func: "values", args: [CallMethod { d: Step, method: "map", args: [] }] }, vec2: CallMethod { d: Arch, method: "magic_state_qubits", args: [] } }, vec2: FoldExpr { container: MapIterExpr { container: CallMethod { d: Step, method: "implemented_gates", args: [] }, bound_var: "x", func: GetAnonData { ident: "x", access: Access("implementation", TupleAccess(CallFunction { func: "tree", args: [] }, Nil)) } }, init: EmptyVec, func: Extend { vec1: Ident("acc"), vec2: Ident("x") } } }] }, bound_var: "x", func: ImplConstructorExpr([("tree", Ident("x"))]) }, els: MapIterExpr { container: CallFunction { func: "steiner_trees", args: [Ident("arch"), Extend { vec1: Extend { vec1: Extend { vec1: Extend { vec1: Extend { vec1: EmptyVec, vec2: MapIterExpr { container: CallMethod { d: Gate, method: "x_indices", args: [] }, bound_var: "x", func: CallFunction { func: "horizontal_neighbors", args: [MapAccess(Ident("x")), GetData { d: Arch, access: Access("width", Nil) }] } } }, vec2: MapIterExpr { container: CallMethod { d: Gate, method: "z_indices", args: [] }, bound_var: "x", func: CallFunction { func: "vertical_neighbors", args: [MapAccess(Ident("x")), GetData { d: Arch, access: Access("width", Nil) }, GetData { d: Arch, access: Access("height", Nil) }] } } }, vec2: MapIterExpr { container: CallMethod { d: Gate, method: "y_indices", args: [] }, bound_var: "x", func: CallFunction { func: "vertical_neighbors", args: [MapAccess(Ident("x")), GetData { d: Arch, access: Access("width", Nil) }, GetData { d: Arch, access: Access("height", Nil) }] } } }, vec2: MapIterExpr { container: CallMethod { d: Gate, method: "y_indices", args: [] }, bound_var: "x", func: CallFunction { func: "horizontal_neighbors", args: [MapAccess(Ident("x")), GetData { d: Arch, access: Access("width", Nil) }] } } }, vec2: MapIterExpr { container: CallMethod { d: Arch, method: "magic_state_qubits", args: [] }, bound_var: "x", func: CallFunction { func: "horizontal_neighbors", args: [Ident("x"), GetAnonData { ident: "arch", access: Access("width", Nil) }] } } }, Extend { vec1: Extend { vec1: CallFunction { func: "values", args: [CallMethod { d: Step, method: "map", args: [] }] }, vec2: CallMethod { d: Arch, method: "magic_state_qubits", args: [] } }, vec2: FoldExpr { container: MapIterExpr { container: CallMethod { d: Step, method: "implemented_gates", args: [] }, bound_var: "x", func: GetAnonData { ident: "x", access: Access("implementation", TupleAccess(CallFunction { func: "tree", args: [] }, Nil)) } }, init: EmptyVec, func: Extend { vec1: Ident("acc"), vec2: Ident("x") } } }] }, bound_var: "x", func: ImplConstructorExpr([("tree", Ident("x"))]) } } }, trans: TransitionBlock { data: NamedTuple { name: "Id", fields: [("na", LocationTy)] }, apply: CallFunction { func: "identity_application", args: [Ident("step")] }, cost: FloatLiteral(0.0), get_transitions: Append { vec: EmptyVec, elem: TransitionConstructor([("na", LocationLiteral(0))]) } }, arch: Some(ArchitectureBlock { data: NamedTuple { name: "MQLSSArch", fields: [("magic_state_qubits", VectorTy(LocationTy)), ("alg_qubits", VectorTy(LocationTy)), ("width", IntTy), ("height", IntTy)] }, get_locations: Some(CallMethod { d: Arch, method: "alg_qubits", args: [] }) }), step: Some(StepBlock { cost: FloatLiteral(1.0) }) }